import unittest
from phase_1 import *

#In this unittest, we implicitly trust the implementation
#Of Schnorr and Dilithium key generation and verification.
#We also trust that RawProxy and all the functions a proxy can run
#Are properly tested and generate reliable outputs.
class TestPhaseOne(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # Runs only once before all tests
        cls.rpc_url = 'http://joshuageorgedai:333777000@127.0.0.1:18443/wallet/myaddress'
        cls.proxy = RawProxy(service_url=cls.rpc_url)
    
    #Test the fund implementation
    #Generate 50 Bitcoins to a given address
    def test_fund(self):
        address = self.proxy.getnewaddress()
        utxos = self.proxy.listunspent(1, 9999999, [address])
        balance = sum(utxo['amount'] for utxo in utxos)
        fund(self.proxy, address, 1)

        utxos = self.proxy.listunspent(1, 9999999, [address])
        balance = sum(utxo['amount'] for utxo in utxos)
        info = self.proxy.getblockchaininfo()
        n_halvings = (info['blocks']- 101) // 210000
        reward = 50 / (2 ** n_halvings)
        self.assertAlmostEqual(reward, balance, 3)
    
    #Test Schnorr to x-only. All Schnorr signatures and their x-only
    #Test cases generated by ChatGPT code in test_x_only.py
    def test_x_only_generation(self):
        schnorr_pubkey_1 = (66788082082811384554278116166345140784137512697203535060075388852347835178160, 59619315663467068298546658606359339808075246385580017745660268896078962370893)
        schnorr_x_only_1 = b'\x93\xa8\xb7\x00\x8a\xb3\xa2\xd2=5J\x9d\x12\x9e\xc8\xee\xf2\x1f\xac\xfa\x15\xce\nS}~\xdfhU\x96\xdc\xb0'
        schnorr_pubkey_2 = (67286359420881373664609389062353427699971543351037666624419357595696686156118, 39716962531884350163350684757354565579374965353081046679790590972883308907562)
        schnorr_x_only_2 = b"\x94\xc2\xba\xd66\x85\xab'd\xc9\xcae8C\xbc\x16\x10\xfd\x16\xa5\xfc\xfb<V;*pS\xfa\xdb\xc9V"
        schnorr_pubkey_3 = (91816766806231396788961638262335907310356265129354597050271282747470287469068, 79526871277422327209521899524311064935393028987313200267214110892781284108759)
        schnorr_x_only_3 = b'\xca\xfer\xc9\xbd3$\xd5*\x03\xf8\xc6\xa9\x0c\xa7S\x00:\x9du\x9b\x95]K\x1e\xfaV,\xb2\xbb\xfa\x0c'
        self.assertEqual(schnorr_to_xonly(schnorr_pubkey_1),schnorr_x_only_1)
        self.assertEqual(schnorr_to_xonly(schnorr_pubkey_2),schnorr_x_only_2)
        self.assertEqual(schnorr_to_xonly(schnorr_pubkey_3),schnorr_x_only_3)
    
    #Test format script function to ensure the opcodes
    #Match their given byte format, with the schnorr signature
    #Taken from the last test
    #Dilithium pubkey generated by chatGPT
    def test_script_byte_format(self):
        schnorr_pubkey = (66788082082811384554278116166345140784137512697203535060075388852347835178160, 59619315663467068298546658606359339808075246385580017745660268896078962370893)
        x_only_pubkey = schnorr_to_xonly(schnorr_pubkey)
        dilithium_pubkey = b'\xeb\x14\x06 \x82\xa6\x8aX"pm\xbf\x17\x9d\xaa>\xa5~\xed\xa6\xfbA\xd5N;\x10T8\xe4\xafW\xbf\xd4\xc0j\xfadr\x1e\x07M\xd5\x08\x86\x80\x02\xb9\xf2\x13:\x87\xe0\x98eI\xd9/\xf2\xf5\x11Y \xd10(~\x100\xa8\xd4/\xf8Zt\x13bE\x07+\xd0\xc5\xa08\x91\xc6*ZWA\xaa\xc9%\xe0z#\xf8\r\x92\x11\xd9\x8c\x8d\x0c\xde\r\x18J\x0c\x17"\x98@\xfax\xb3\x8d\t9\xbd\x9aG\xcb\x164\xf8+,jc\xc3\x10\x86\xcb\x88I\xd4\x99\x89\xf2\xd0\xc0\xd2\x01\x97\xf4\x07\xf5b_\xa68\x94g\xc0vn\x0c\x80\xb2PK\xdb\xca\x9b\x14A\xa7\'\x10\xc0\xa0PY&\x80\xcfO\xb2(}u\x0f_\x99\xdfMv9\xe2\xd3\x16-\xe3\x00E\xc76\xadx0\xba?\xa2\x0b\xa68*G\xf3\xb1\x1fM\xc9 \x8fH1\xa14\xb7\xc9\x1e\x94@\xa1\x97xoI\x99\x17\x9eL\x0f\xc0\x03WOQ,\xe6\xa3\xc5\xe3\xd1\xec\x14\xac\x18\xc8;z\xa7ss\x81u\x83\x9aUM\x1d\x96\xf0(;\x8e\xbc\xea\x85[\x1f\xedW\xd9\'\x0e\xce\xe0\xc2\xd2\x8b\xec\xae\xa9X}A\x1a\xa9\xdf\xfei\xfaY\xa7wdV\xbc\xba5\x9b\x8b\xe8\x1awf\xb0\xa2\xd0Z^\x84\xbf`\xef\x01\xab|+\xb8\x90\xd7a<\x02\xc5O\xf1\xb9v\x86\xef\x16\x88AK\x90\xcep\n`G\x05\x8e\xa2s\x04W\xe8\x17A#*>\xf1"C\xdb\x00\xe6T\xad\xf4\xa2VV\x11P\x17\x1eL\xbe\xe8\xf9\xfbw4\x1e\xce\xb1,\xe1\x14\xd0\x13\x98\x86\xc4n\xf3,\xcfQ\x14*.\x1b\x9b/\xb8\xa6@5\x8b\x88\t\xea\xbc\xda\x18\xb5wk\x1aE\xc5U,\r5L\x88Hi\xc5Oj\x8b\xd8\x83\x9a;,\xaa\xc5{\x0fj\x8e\x90\x19\xf4\xbc\xf7}\x80\n\xbb\xa6\xba\x9a\xc3\x9f\t$DD}GFC\x95\xe0\x82\x01\xa8l\xc3\xce\xcf\x11*4\x9f=\t\xa7\x18\x0e\xfe\xa2\x93\xe8\xb8(\x0e\x87\x8e\x7fE\x05\xd4\x82w?\x16X\x05&},\xc0\xe7\x16\x90\xaf{\xae\\u`\x9a\x90\xbc\xba8ct)DG0\xa1\ns\x11-\x92\x08\xb6?\x8a\xe6\xf0sj\xbf\xeel\x1fva\x8a.\xe5\xe8\x1a\x02\x96\xc6\xb0,\xac\xcd\x95?2XG\x10\xad\x82?\xeb\xb6J\\L\xc7\x1bw^\xc7\x86\xbbUjxU]\xa7\x87W(R`$r\x9c\x11x\xd2\xfdt\xac?\xc2\x9b\xd6\x93\xed\xd7\x07\xd1\xbf~\xad\xf1\xf4e\xcapN\xdc\x1ep\xd2\x07A!\xdb\xb4 RZ\x12l^\x93-\xc7\x94\xd3\xaa\x85\xe0Xr\xbe\xfb)\xbd\x1d\x91\xbc/\x14E<\x15\xe5\xbe\xcf\x8f-9#\x1c\xaaTUK\xd5\x07\x1d&~{R\xc2/\x8fl\xd8\x84\x0b\x89\xde8\xc4Ef"9\xa6}g\x04\xc6\xf4\xcc\x98\xbeJ\xa4\xb0\xbdR\x06\xfb/\xd4\xb0Qm\xcf6\x9a\xfe\xfc\xfa^\xb5\xdb\xc1\x1bm\x00\x82}AZ\xa8\xfdhFi\x11%\xe9\x8bg\x1bz\x8c\xb5\xde\'\x9b\x0f\xe62.\x1d\xf8\xd9g?Z\x99%\xa0\xcd\x15\xad`(\xf9v\xb8\xa8).\xab\x95\'\x9d\x08>\x0b2\xf8\x16\xd3\xdb\xc7d\xf8\xf1\xa3P\x02\x94gd\xe1\xd4\xc6\x04B\xcfPC\xba\xccM\x8a\x98\xc9[\xf6\x873\x80\xfaw\x01\xd9\xf1\x97*\x0c\xc6`\xbcz\xd37\x88Z\xb0x|\x90\xab\xb7\xcd\xef\x13\x0f\xab\xf5\xa6\xc7\xf1\xabF\x0cx\x06\xd03\xb4"\x86)c\xc7\x04\x0e\xd5 \xc2@\xab\xd2\x9a\x00\xd8\x92\xcabl\xee\x93\x8b\xb76.\x85\x91\xe1y_\xd3~\xe63Yw]sU\xad<S6\xbe\x14\xcf\xb2\n\x9e\xc7\x9f\x85\x04\x1e\xf2\r\x8aU\xbe\xe8\x0b\xc9^\xd22\xf8\x9b\x1a\x1fF\xb5Ou\xe8\'\xea\xc1#\x95\xdbj\xcc\x81f\xe7w\x96\xd7?\xe2\x07\xb3\xe4\x08S+WF\xf9u`]\x19\xdc\x9f\x9b\x141\xa3\x80\xbbs7\xfc\x03\x03\x11Hw\xf5\xd3>X\xc5\xf0\xf4s\xd3\xab\x10P\x84\xc9\xbf\x88oa\xe9/#?-\xffq\xa2k-c\x0bS\x9c\x8bVJ\xe1hZ\x16\x90qN>\xa9\x0f\xd4\xd4\xd43\xa5t\xba1\xaa\xa1\'\x19\x83x\x83\nh\x13z,{\xb0\xd6N`\xc9sR\x08\x8c\xad\xa2\xc46*\xa9\xa0X\xc4P\xa7\xd3)\x93\x9a\xdd!Xbc\xb1\xbdm\xd9\x0f\x94\xd0\xfe\xae16\xbe\\\x85U\xa5+gV2V\xc2\x03K~\x8a53\xc8\xec\xb7\x89|.\x00\x85\x07\xffv\x05\xf8\x005\xdc\xab\xe8\x96\xb4g\xa6ii\xd9\xe3\xd4\x1d{\xf0\x92\x10\x97\x0b\xf4\x8cCq\xff\xe6:\xe6,\xd3%\xd6\xf0\x04ne<|\xfc\x04\x926\xd1\x87qY/!0[\xabl\x05NgT\xe7\x14\xb5\x90\xa1\xda\x02\xd7J} =\x85\xb4\xd2\x95\x18X\xae\x8c\x02Bs\x8e\xe6%\xb1u\x95\xd8r\xd59\xfe\xd0\x1d\xbd\x8c\xb3P\x877G\xbe\x08\xd1\xeb\xfd\xaf\xbd\xfaZfDPO\xa6\x86\xdd{\x13\xc2\xdc\xfa#ro\xfb\xa7\x92\x0c\xb0\xff;\xe4\xdd@t\xa4\xc4\xc7\x7f\x1e\xc0\xb6d\x00s\x91=\xf4\xc3\xad\x96\xddA\xe9\xc8\xe8\x05\xac\xbc+r5\xa3\xcd\xdc\x9bxplEr\xe7\x89\x91\xda(\x92\xe6\xb2us\x1d\xfd\xb2\x0c\x8a\xff\xa9B\xb5\x03\xe4\xc7\xd1\xe1\x11\xb4\x97\x8dG\x7f\xd4\r\xc0k\xeer\x84\xdaj\xd0'
        script = f"OP_IF\n{int.from_bytes(x_only_pubkey, byteorder='little')} OP_CHECKSIG\nOP_ELSE\n{int.from_bytes(dilithium_pubkey, byteorder='little')} OP_CHECKDILITHIUMSIG\nOP_ENDIF"
        intended_output = b'\x63'+struct.pack('B', len(x_only_pubkey))+x_only_pubkey+b'\xac'+b'\x67'+b'\x4d'+struct.pack('>H', len(dilithium_pubkey))[::-1]+dilithium_pubkey+b'\xc0'+b'\x68'
        self.assertEqual(script_byte_format(script), intended_output)

    #Test the schnorr path of the script and see if verification is successful
    def test_schnorr_verification(self):
        schnorr_private_key, schnorr_public_key = dsa.gen_keys()

        #Dilithum keys generated as byte strings
        dil_public_key, dil_private_key = dilithium.Dilithium2.keygen()

        #Generate new taproot address
        address = self.proxy.getnewaddress("", "bech32m")

        #Fund address 50 bitcoin
        fund(self.proxy, address, 1)

        #We hard code our scripts used by the hybrid wallet
        script_path_schnorr = f"{int.from_bytes(schnorr_to_xonly(schnorr_public_key), byteorder='little')} OP_CHECKSIG"
        script_path_dil = f"{int.from_bytes(dil_public_key, byteorder='little')} OP_CHECKDILITHIUMSIG"

        #Generate scriptPubKey following Bitcoin protocol
        leaf_ver = b'\xc0'
        schnorr_path_bytes = script_byte_format(script_path_schnorr)
        schnorr_path_hash = hashlib.sha256((hashlib.sha256("TapLeaf".encode()).digest() * 2) +leaf_ver+compact_size(len(schnorr_path_bytes))+ schnorr_path_bytes).digest()
        dil_path_bytes = script_byte_format(script_path_dil)
        dil_path_hash = hashlib.sha256((hashlib.sha256("TapLeaf".encode()).digest() * 2) +leaf_ver+compact_size(len(dil_path_bytes))+ dil_path_bytes).digest()
        hashed_script_list = [schnorr_path_hash, dil_path_hash]
        merkle_branch = (hashlib.sha256("TapBranch".encode()).digest() * 2)
        for branch in sorted(hashed_script_list):
            merkle_branch += branch
        merkle_branch = hashlib.sha256(merkle_branch).digest()
        # Use a NUMS pubkey to force script spending
        NUMS_pubkey = bytes.fromhex("0000000000000000000000000000000000000000000000000000000000000001")
        tweak = hashlib.sha256(hashlib.sha256("TapTweak".encode()).digest() + hashlib.sha256("TapTweak".encode()).digest() + NUMS_pubkey + merkle_branch).digest()
        #Generator is the generator we used to get our Schnorr
        #Public key and private key
        internal_pubkey = PublicKey(b'\x02' + NUMS_pubkey, raw=True)
        scriptPubKey = internal_pubkey.tweak_add(tweak).serialize()[1:]

        #Script path boolean to determine which public and private key to use
        #True is Schnorr, False is Dilithium
        script_path_bool = True
        self.assertEqual(witness_verification(self.proxy, 1, schnorr_public_key, dil_public_key, schnorr_private_key, dil_private_key, script_path_bool, script_path_schnorr, script_path_dil, scriptPubKey), True)

    #Test the Dilithium path of the script and see if verification is successful
    def test_dilithium_verification(self):
        schnorr_private_key, schnorr_public_key = dsa.gen_keys()

        #Dilithum keys generated as byte strings
        dil_public_key, dil_private_key = dilithium.Dilithium2.keygen()

        #Generate new taproot address
        address = self.proxy.getnewaddress("", "bech32m")

        #Fund address 50 bitcoin
        fund(self.proxy, address, 1)

        #We hard code our scripts used by the hybrid wallet
        script_path_schnorr = f"{int.from_bytes(schnorr_to_xonly(schnorr_public_key), byteorder='little')} OP_CHECKSIG"
        script_path_dil = f"{int.from_bytes(dil_public_key, byteorder='little')} OP_CHECKDILITHIUMSIG"

        #Generate scriptPubKey following Bitcoin protocol
        leaf_ver = b'\xc0'
        schnorr_path_bytes = script_byte_format(script_path_schnorr)
        schnorr_path_hash = hashlib.sha256((hashlib.sha256("TapLeaf".encode()).digest() * 2) +leaf_ver+compact_size(len(schnorr_path_bytes))+ schnorr_path_bytes).digest()
        dil_path_bytes = script_byte_format(script_path_dil)
        dil_path_hash = hashlib.sha256((hashlib.sha256("TapLeaf".encode()).digest() * 2) +leaf_ver+compact_size(len(dil_path_bytes))+ dil_path_bytes).digest()
        hashed_script_list = [schnorr_path_hash, dil_path_hash]
        merkle_branch = (hashlib.sha256("TapBranch".encode()).digest() * 2)
        for branch in sorted(hashed_script_list):
            merkle_branch += branch
        merkle_branch = hashlib.sha256(merkle_branch).digest()
        # Use a NUMS pubkey to force script spending
        NUMS_pubkey = bytes.fromhex("0000000000000000000000000000000000000000000000000000000000000001")
        tweak = hashlib.sha256(hashlib.sha256("TapTweak".encode()).digest() + hashlib.sha256("TapTweak".encode()).digest() + NUMS_pubkey + merkle_branch).digest()
        #Generator is the generator we used to get our Schnorr
        #Public key and private key
        internal_pubkey = PublicKey(b'\x02' + NUMS_pubkey, raw=True)
        scriptPubKey = internal_pubkey.tweak_add(tweak).serialize()[1:]

        #Script path boolean to determine which public and private key to use
        #True is Schnorr, False is Dilithium
        script_path_bool = False
        self.assertEqual(witness_verification(self.proxy, 1, schnorr_public_key, dil_public_key, schnorr_private_key, dil_private_key, script_path_bool, script_path_schnorr, script_path_dil, scriptPubKey), True)
    
    #Test if a wrong scriptPubKey raises an error
    #Essentially, this tests if confirm_tweak is working as intended
    def test_wrong_scriptPubKey_verification(self):
        schnorr_private_key, schnorr_public_key = dsa.gen_keys()

        #Dilithum keys generated as byte strings
        dil_public_key, dil_private_key = dilithium.Dilithium2.keygen()

        #Generate new taproot address
        address = self.proxy.getnewaddress("", "bech32m")

        #Fund address 50 bitcoin
        fund(self.proxy, address, 1)

        #We hard code our scripts used by the hybrid wallet
        script_path_schnorr = f"{int.from_bytes(schnorr_to_xonly(schnorr_public_key), byteorder='little')} OP_CHECKSIG"
        script_path_dil = f"{int.from_bytes(dil_public_key, byteorder='little')} OP_CHECKDILITHIUMSIG"

        #Generate scriptPubKey following Bitcoin protocol
        leaf_ver = b'\xc0'
        schnorr_path_bytes = script_byte_format(script_path_schnorr)
        #Added a 1 byte mistake to the script pub key
        schnorr_path_hash = hashlib.sha256((hashlib.sha256("TapLeaf".encode()).digest() * 2) +leaf_ver+compact_size(len(schnorr_path_bytes))+ schnorr_path_bytes + b'\x00').digest()
        dil_path_bytes = script_byte_format(script_path_dil)
        dil_path_hash = hashlib.sha256((hashlib.sha256("TapLeaf".encode()).digest() * 2) +leaf_ver+compact_size(len(dil_path_bytes))+ dil_path_bytes).digest()
        hashed_script_list = [schnorr_path_hash, dil_path_hash]
        merkle_branch = (hashlib.sha256("TapBranch".encode()).digest() * 2)
        for branch in sorted(hashed_script_list):
            merkle_branch += branch
        merkle_branch = hashlib.sha256(merkle_branch).digest()
        # Use a NUMS pubkey to force script spending
        NUMS_pubkey = bytes.fromhex("0000000000000000000000000000000000000000000000000000000000000001")
        tweak = hashlib.sha256(hashlib.sha256("TapTweak".encode()).digest() + hashlib.sha256("TapTweak".encode()).digest() + NUMS_pubkey + merkle_branch).digest()
        #Generator is the generator we used to get our Schnorr
        #Public key and private key
        internal_pubkey = PublicKey(b'\x02' + NUMS_pubkey, raw=True)
        scriptPubKey = internal_pubkey.tweak_add(tweak).serialize()[1:]

        #Script path boolean to determine which public and private key to use
        #True is Schnorr, False is Dilithium
        script_path_bool = False
        #See if an error is raised
        with self.assertRaises(ValidationError):
            witness_verification(self.proxy, 1, schnorr_public_key, dil_public_key, schnorr_private_key, dil_private_key, script_path_bool, script_path_schnorr, script_path_dil, scriptPubKey)

if __name__ == '__main__':
    unittest.main()